<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux之用户管理</title>
      <link href="/2019/09/08/Linux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2019/09/08/Linux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="用户管理的规则"><a href="#用户管理的规则" class="headerlink" title="用户管理的规则"></a>用户管理的规则</h4><ol><li><p>Linux系统是一个<strong>多用户多任务</strong>的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p></li><li><p>Linux用户至少要属于一个分组。</p></li><li><p>用户家目录：/home/目录下有各个用户创建的家目录，当用户登录时，会自动进入到自己的家目录。例如用户chen对应/home/chen。</p></li></ol><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br></pre></td></tr></table></figure><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>也可以通过 useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</li></ol><h4 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a><strong>指定/修改密码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cpasswd.png" alt="title"></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><strong>删除用户</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><ol><li>删除用户chen，但是要保留家目录（userdel  用户名）</li><li>删除用户以及用户主目录（userdel  -r  用户名）</li></ol><h4 id="查询用户信息指令"><a href="#查询用户信息指令" class="headerlink" title="查询用户信息指令"></a><strong>查询用户信息指令</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cid.png" alt="title"></p><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a><strong>切换用户</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su – 切换用户名</span><br></pre></td></tr></table></figure><p>在操作Linux中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如root。</p><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Csu.png" alt="title"></p><p><strong>注意：</strong></p><ol><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</li><li>当需要返回到原来用户时，使用exit指令。</li></ol><h4 id="查看当前用户-登录用户"><a href="#查看当前用户-登录用户" class="headerlink" title="查看当前用户/登录用户"></a><strong>查看当前用户/登录用户</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami 或者 who am I</span><br></pre></td></tr></table></figure><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a><strong>用户组</strong></h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p><h4 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><h4 id="增加用户时直接加上组"><a href="#增加用户时直接加上组" class="headerlink" title="增加用户时直接加上组"></a>增加用户时直接加上组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd –g 用户组 用户名</span><br></pre></td></tr></table></figure><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cuseradd.png" alt="title"></p><h4 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod –g 用户组 用户名</span><br></pre></td></tr></table></figure><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cusermod.png" alt="title"></p><h4 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a><strong>用户和组的相关文件</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 文件</span><br></pre></td></tr></table></figure><p>用户（user）的配置文件，记录用户的各种信息</p><p>每行的含义： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cetc.png" alt="title"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 文件</span><br></pre></td></tr></table></figure><p> 口令的配置文件</p><p> 每行的含义： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cshadow.png" alt="title"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/group 文件</span><br></pre></td></tr></table></figure><p> 组(group)的配置文件，记录Linux包含的组的信息</p><p> 每行含义： 组名:口令:组标识号:组内用户列表</p><p><img src="//cxmda.github.io/2019/09/08/Linux之用户管理/D:%5Chexo%5Cblog%5Csource_posts%5CLinux%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%5Cgroup.png" alt="title"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建多线程的方式有几种</title>
      <link href="/2019/09/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2019/09/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍多线程"><a href="#介绍多线程" class="headerlink" title="介绍多线程"></a>介绍多线程</h3><h4 id="1-介绍一下进程和线程"><a href="#1-介绍一下进程和线程" class="headerlink" title="1. 介绍一下进程和线程"></a>1. 介绍一下进程和线程</h4><p>进程：是程序的一次执行，或者是正在运行的一个程序，如运行中的QQ、微信。</p><p>线程：是进程中的一条执行路径。一个进程中最少有一个线程，若一个线程同一时间并行执行多个线程，就是支持多线程的。</p><h4 id="2-并行与并发"><a href="#2-并行与并发" class="headerlink" title="2. 并行与并发"></a>2. 并行与并发</h4><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事情。</p><p>并发：一个CPU（采用时间片）同时执行多个任务。比如：秒杀。</p><h3 id="Java创建多线程的方式有四种"><a href="#Java创建多线程的方式有四种" class="headerlink" title="Java创建多线程的方式有四种"></a>Java创建多线程的方式有四种</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. <strong>继承Thread类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程的创建方式一：继承Thread类</span></span><br><span class="line"><span class="comment"> * 例子：遍历100以内的偶数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个类继承Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重写父类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> +i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.调用start():①：启动当前线程 ②：调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不能通过调用run()方法来启动线程</span></span><br><span class="line">        <span class="comment">//t1.run();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + i );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a><strong>2. 实现Runnable接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建多线程的方式二：实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//1.创建一个对象实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">// 2.实现接口中的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建实现了Runnable接口的对象的实例</span></span><br><span class="line">        WThread wThread = <span class="keyword">new</span> WThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.创建Thread对象，参数为实现了Runnable接口的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(wThread);</span><br><span class="line">        t1.setName(<span class="string">"线程一"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.使用Thread对象调用start()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(wThread);</span><br><span class="line">        t2.setName(<span class="string">"线程二"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a><strong>3. 实现Callable接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式三：实现Callable接口 JDK5.0新增</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.实现Callable接口的call()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口的实现类的对象</span></span><br><span class="line">        NewThread newThread = <span class="keyword">new</span> NewThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.将此Callable接口的实现类的对象传递到FutureTask的构造器中，创建FutureTask对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(newThread);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.创建Thread对象，参数为FutureTask对象，调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable接口中的call()的返回值</span></span><br><span class="line">            <span class="comment">//get()的返回值为Callable接口中的call()的返回值</span></span><br><span class="line">            Object value = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"总和为："</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a><strong>4. 使用线程池</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的方式四：线程池</span></span><br><span class="line"><span class="comment"> * 线程池的体系结构：</span></span><br><span class="line"><span class="comment"> *     java.util.concurrent.Executor：负责线程的使用与调度的根接口</span></span><br><span class="line"><span class="comment"> *         |--ExecutorService 子接口：线程池的主要接口</span></span><br><span class="line"><span class="comment"> *             |--ThreadPoolExecutor：线程池的实现类</span></span><br><span class="line"><span class="comment"> *             |--ScheduledExecutorService 子接口：负责线程的调度</span></span><br><span class="line"><span class="comment"> *                 |--ScheduledThreadPoolExecutor：继承 ThreadPoolExecutor，实现 ScheduledExecutorService</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 工具类 : Executors</span></span><br><span class="line"><span class="comment"> * ExecutorService newFixedThreadPool() : 创建固定大小的线程池</span></span><br><span class="line"><span class="comment"> * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更 改数量。</span></span><br><span class="line"><span class="comment"> * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</span></span><br><span class="line"><span class="comment"> * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> +i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">        service1.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
